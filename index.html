<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Hexo</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/18/前端路由实现笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/前端路由实现笔记/" itemprop="url">前端路由实现笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-18T22:26:08+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="HashHistory"><a href="#HashHistory" class="headerlink" title="HashHistory"></a>HashHistory</h2><ul>
<li>hash（“#”）符号的本来作用是加在URL中指示网页中的位置,#符号本身以及它后面的字符称之为hash，可通过window.location.hash属性读取。</li>
</ul>
<p>hash的特点：</p>
<ol>
<li><p>hash虽然出现在URL中，但不会被包括在HTTP请求中。它是用来指导浏览器动作的，对服务器端完全无用，因此，改变hash不会重新加载页面。</p>
</li>
<li><p>可以为hash的改变添加监听事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">window.addEventListener(&quot;hashchange&quot;, function()&#123;&#125;, false)</div></pre></td></tr></table></figure>
</li>
<li><p>每一次改变hash（window.location.hash），都会在浏览器的访问历史中增加一个记录</p>
</li>
</ol>
<ul>
<li>通过修改hash值，并使页面作出相应处理，则可实现改变路由，同时不重新加载页面，修改hash的方法：</li>
</ul>
<ol>
<li>实现HashHistory.push()</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function pushHash (path) &#123;</div><div class="line">  window.location.hash = path // 直接修改hash值</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>实现HashHistory.replace()，它并不是将新路由添加到浏览器访问历史的栈顶，而是替换掉当前的路由</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function replaceHash (path) &#123;</div><div class="line">  const i = window.location.href.indexOf(&apos;#&apos;) // 地址字符串中&apos;#&apos;的位置</div><div class="line">  window.location.replace(</div><div class="line">    window.location.href.slice(0, i &gt;= 0 ? i : 0) + &apos;#&apos; + path</div><div class="line">  ) // 把地址替换成我们想要的地址</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>手动修改地址栏上的地址， 监听方法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">window.addEventListener(&apos;hashchange&apos;, () =&gt; &#123;&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="HTML5History"><a href="#HTML5History" class="headerlink" title="HTML5History"></a>HTML5History</h2><ul>
<li>History interface是浏览器历史记录栈提供的接口，通过back(), forward(), go()等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。从HTML5开始，History interface提供了两个新的方法：pushState(), replaceState()使得我们可以对浏览器历史记录栈进行修改.</li>
</ul>
<ol>
<li>window.history.pushState(stateObject, title, Url)</li>
</ol>
<p>state object — 状态对象是一个由 pushState()方法创建的、与历史纪录相关的JS对象。当用户定向到一个新的状态时，会触发popstate事件。事件的state属性包含了历史纪录的state对象。（译者注：总而言之，它存储JSON字符串，可以用在popstate事件中。）state 对象可以是任何可以序列化的东西。</p>
<p>title — 火狐浏览器现在已经忽略此参数，将来也许可能被使用。考虑到将来有可能的改变，传递一个空字符串是安全的做法。当然，你可以传递一个短标题给你要转变成的状态。（现在大多数浏览器不支持或者忽略这个参数，最好用null代替）</p>
<p>URL — 这个参数提供了新历史纪录的地址。请注意，浏览器在调用pushState()方法后不会去加载这个URL，但有可能在之后会这样做，比如用户重启浏览器之后。新的URL不一定要是绝对地址，如果它是相对的，它一定是相对于当前的URL。新URL必须和当前URL在同一个源下;否则，pushState() 将丢出异常。这个参数可选，如果它没有被特别标注，会被设置为文档的当前URL。</p>
<p>eg:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var state = &#123; &apos;page_id&apos;: 1, &apos;user_id&apos;: 5 &#125;;</div><div class="line">var title = &apos;Hello World&apos;;</div><div class="line">var url = &apos;hello-world.html&apos;;</div><div class="line"></div><div class="line">window.history.pushState(state, title, url);</div><div class="line"></div><div class="line">// 然后查看 window.history,会发现History的length +1, state里有上一个state的内容</div></pre></td></tr></table></figure>
<ol>
<li>window.history.pushState(stateObject, title, Url) 用法同上，结果length不变，state里为替代的state的内容</li>
</ol>
<ul>
<li>这两个方法有个共同的特点：</li>
</ul>
<p>当调用他们修改浏览器历史记录栈后，虽然当前URL改变了，但浏览器不会立即发送请求该URL（the browser won’t attempt to load this URL after a call to pushState()），这就为单页应用前端路由“更新视图但不重新请求页面”提供了基础。</p>
<ul>
<li>这种方法又是如何监听手动输入地址栏的呢？答案如下:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">window.addEventListener(&apos;popstate&apos;, e =&gt; &#123;&#125;);</div></pre></td></tr></table></figure>
<ul>
<li>如何判断浏览器是否支持HTML5的新特性：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function judgeHtml5Support() &#123;</div><div class="line">  const ua = window.navigator.userAgent</div><div class="line">  if (</div><div class="line">    (ua.indexOf(&apos;Android 2.&apos;) !== -1 || ua.indexOf(&apos;Android 4.0&apos;) !== -1) &amp;&amp;</div><div class="line">    ua.indexOf(&apos;Mobile Safari&apos;) !== -1 &amp;&amp;</div><div class="line">    ua.indexOf(&apos;Chrome&apos;) === -1 &amp;&amp;</div><div class="line">    ua.indexOf(&apos;Windows Phone&apos;) === -1</div><div class="line">  ) &#123;</div><div class="line">    return false</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="两者比较"><a href="#两者比较" class="headerlink" title="两者比较"></a>两者比较</h3><ul>
<li>history.pushState()相比于直接修改hash主要有以下优势：</li>
</ul>
<ol>
<li><p>pushState设置的新URL可以是与当前URL同源的任意URL；而hash只可修改#后面的部分，故只可设置与当前同文档的URL</p>
</li>
<li><p>pushState设置的新URL可以与当前URL一模一样，这样也会把记录添加到栈中；而hash设置的新值必须与原来不一样才会触发记录添加到栈中</p>
</li>
<li><p>pushState通过stateObject可以添加任意类型的数据到记录中；而hash只可添加短字符串</p>
</li>
<li><p>pushState可额外设置title属性供后续使用</p>
</li>
</ol>
<ul>
<li>history模式的问题:</li>
</ul>
<p>用户直接在地址栏中输入并回车，浏览器重启重新加载应用，history模式会将URL修改得就和正常请求后端的URL一样，在此情况下重新向后端发送请求，如后端没有配置对应的路由处理，则会返回404错误。官方推荐的解决办法是在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。同时这么做以后，服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。或者，如果是用 Node.js 作后台，可以使用服务端的路由来匹配 URL，当没有匹配到路由的时候返回 404，从而实现 fallback。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://zhuanlan.zhihu.com/p/27588422" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/27588422</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/18/关于vue双向数据绑定实现的学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/关于vue双向数据绑定实现的学习/" itemprop="url">关于vue双向数据绑定实现的学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-18T22:25:05+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="学习vue的双向数据绑定首先要知道几个知识点"><a href="#学习vue的双向数据绑定首先要知道几个知识点" class="headerlink" title="学习vue的双向数据绑定首先要知道几个知识点:"></a>学习vue的双向数据绑定首先要知道几个知识点:</h2><h3 id="1-Object-defineProperty-用于劫持数据"><a href="#1-Object-defineProperty-用于劫持数据" class="headerlink" title="1.Object.defineProperty : 用于劫持数据"></a>1.Object.defineProperty : 用于劫持数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">Object.defineProperty(obj, prop, descriptor)</div><div class="line"></div><div class="line">参数</div><div class="line"></div><div class="line">obj</div><div class="line">需要被操作的目标对象</div><div class="line">prop</div><div class="line">目标对象需要定义或修改的属性的名称。</div><div class="line">descriptor</div><div class="line">将被定义或修改的属性的描述符。</div><div class="line"></div><div class="line">返回值</div><div class="line"></div><div class="line">被传递给函数的对象。</div><div class="line"></div><div class="line">eg:</div><div class="line">  var obj = &#123; &#125;; // 为obj定义一个名为 hello 的访问器属性</div><div class="line"></div><div class="line">  Object.defineProperty(obj, &quot;hello&quot;, &#123;</div><div class="line"></div><div class="line">    get: function () &#123;return sth&#125;,</div><div class="line"></div><div class="line">    set: function (val) &#123;/* do sth */&#125;</div><div class="line"></div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  obj.hello // 可以像普通属性一样读取访问器属性</div><div class="line"></div><div class="line">  访问器属性的&quot;值&quot;比较特殊，读取或设置访问器属性的值，实际上是调用其内部特性：get和set函数。</div><div class="line"></div><div class="line">  obj.hello // 读取属性，就是调用get函数并返回get函数的返回值</div><div class="line"></div><div class="line">  obj.hello = &quot;abc&quot; // 为属性赋值，就是调用set函数，赋值其实是传参  </div><div class="line"></div><div class="line">ps: descriptor中还能更改以下属性</div><div class="line"></div><div class="line">configurable</div><div class="line">当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。</div><div class="line"></div><div class="line">enumerable</div><div class="line">当且仅当该属性的 enumerable 为 true 时，该属性才能够出现在对象的枚举属性中。默认为 false。</div><div class="line"></div><div class="line">value</div><div class="line">该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。</div><div class="line"></div><div class="line">writable</div><div class="line">当且仅当该属性的 writable 为 true 时，该属性才能被赋值运算符改变。默认为 false。</div></pre></td></tr></table></figure>
<h3 id="2-DocumentFragment-和-appendChild-用于劫持节点"><a href="#2-DocumentFragment-和-appendChild-用于劫持节点" class="headerlink" title="2.DocumentFragment 和 appendChild : 用于劫持节点"></a>2.DocumentFragment 和 appendChild : 用于劫持节点</h3><ul>
<li><p>DocumentFragment</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">描述</div><div class="line"></div><div class="line">DocumentFragment是DOM节点。它们不是主DOM树的一部分。通常的用例是创建文档片段，将元素附加到文档片段，然后将文档片段附加到DOM树。在DOM树中，文档片段被其所有子代替。</div><div class="line"></div><div class="line">由于文档片段位于内存中，而不是主DOM树的一部分，因此将其附加到其上不会导致页面回流（元素的位置和几何的计算）。因此，使用文档片段往往会导致更好的性能。</div></pre></td></tr></table></figure>
</li>
<li><p>appendChild</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">描述</div><div class="line"></div><div class="line">appendChild 方法会把要插入的这个节点引用作为返回值返回.</div><div class="line"></div><div class="line">示例</div><div class="line"></div><div class="line">// 创建一个新的段落p元素,然后添加到body的最尾部</div><div class="line">var p = document.createElement(&quot;p&quot;);</div><div class="line">document.body.appendChild(p);</div><div class="line"></div><div class="line">附注</div><div class="line"></div><div class="line">如果被插入的节点已经存在于当前文档的文档树中,则那个节点会首先从原先的位置移除,然后再插入到新的位置.</div><div class="line"></div><div class="line">如果你需要保留这个子节点在原先位置的显示,则你需要先用Node.cloneNode方法复制出一个节点的副本,然后在插入到新位置.</div><div class="line"></div><div class="line">这个方法只能将某个子节点插入到同一个文档的其他位置,如果你想跨文档插入,你需要先调用document.importNode方法.</div></pre></td></tr></table></figure>
<h3 id="3-发布者与订阅者模式"><a href="#3-发布者与订阅者模式" class="headerlink" title="3.发布者与订阅者模式"></a>3.发布者与订阅者模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 发布者</div><div class="line">var pub = &#123;</div><div class="line">  publish: function() &#123;</div><div class="line">    dep.notify();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 订阅者</div><div class="line">var watcher1 = &#123; update: function () &#123;console.log(1);&#125;&#125;</div><div class="line">var watcher2 = &#123; update: function () &#123;console.log(2);&#125;&#125;</div><div class="line">var watcher3 = &#123; update: function () &#123;console.log(3);&#125;&#125;</div><div class="line"></div><div class="line">// 主题对象</div><div class="line">function Dep() &#123;</div><div class="line">  this.watchers = [watcher1, watcher2, watcher3];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 主题方法</div><div class="line">Dep.prototype.notify = function () &#123;</div><div class="line">  this.watchers.forEach(function (watcher) &#123;</div><div class="line">    watcher.update();</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 发布者发布消息，则调用notify()从而促发订阅者的update</div><div class="line">var dep = new Dep();</div><div class="line">pub.publish();</div></pre></td></tr></table></figure>
<h2 id="Vue双向数据绑定实现流程"><a href="#Vue双向数据绑定实现流程" class="headerlink" title="Vue双向数据绑定实现流程"></a>Vue双向数据绑定实现流程</h2><ol>
<li>劫持el对应的data对象里面的数据，为每个key添加，用于获取及更新数据的getter和setter的方法，并利用闭包的方法，<br>为每个key创建一个独立的dep（主题）对象。</li>
<li>通过documentFragment和appendChild劫持视图，对其所有节点进行重新编译。最后再返回编译结果。</li>
<li>在编译过程中，遍历所有节点，判断节点类型，如果节点有关于数据绑定的指令，则做相应的数据监听处理，并将其创建为watcher对象（即订阅者），通过watcher的getter方法，触发key的getter方法，从而把watcher加到对应的主题当中，<br>一旦key发生改变（节点的数据监听生效，或者js改动data数据），会触发key自身被修改的setter，从而触发主题对象的notify<br>函数，发布更新信息（即调用保存的subs内所有订阅者（watcher）的update函数），最终实现双向数据绑定。</li>
</ol>
<h3 id="具体实现代码如下"><a href="#具体实现代码如下" class="headerlink" title="具体实现代码如下:"></a>具体实现代码如下:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div></pre></td><td class="code"><pre><div class="line">// watcher:订阅者身份 </div><div class="line">function Watcher(vm, node, name, nodeType) &#123;</div><div class="line">  Dep.target = this;</div><div class="line">  this.name = name;</div><div class="line">  this.node = node;</div><div class="line">  this.vm = vm;</div><div class="line">  this.nodeType = nodeType;</div><div class="line">  this.update();</div><div class="line">  Dep.target = null;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Watcher.prototype = &#123;</div><div class="line">  update: function () &#123;</div><div class="line">    this.get();</div><div class="line">    this.node.nodeValue = this.value;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  get: function () &#123;</div><div class="line">    this.value = this.vm[this.name];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 根据节点类型的不同作相应的监听等处理， 共同处理:为每个节点创建watcher订阅者，一旦new watcher调用构造函数，</div><div class="line">// 暂存数据到Dep.target中, 通过watcher的update函数调用watcher的get,从而调动this.vm[this.name],促发在</div><div class="line">// defineReactive中为每个key设置的getter方法，把暂存了该节点（watcher）各种数据的dep.target放到dep(相应</div><div class="line">// 主题)的subs中</div><div class="line">function compile (node, vm) &#123;</div><div class="line">  var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/;</div><div class="line">  // nodeType 返回节点的类型</div><div class="line">  // 1时，节点为元素</div><div class="line">  if (node.nodeType === 1) &#123;</div><div class="line">    // node.attributes 返回标签所有属性 </div><div class="line">    var attr = node.attributes;</div><div class="line">    console.log (attr);</div><div class="line">    for (let i = 0; i &lt; attr.length; i++) &#123;</div><div class="line">      if (attr[i].nodeName == &apos;v-model&apos;) &#123;</div><div class="line">        var name = attr[i].nodeValue;</div><div class="line">        node.addEventListener(&apos;input&apos;, function(e) &#123;</div><div class="line">          vm[name] = e.target.value;</div><div class="line">        &#125;);</div><div class="line">        node.value = vm[name];</div><div class="line">        node.removeAttribute(&apos;v-model&apos;);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    new Watcher(vm, node, name, &apos;input&apos;);</div><div class="line">  &#125;</div><div class="line">  // 3时，节点为text</div><div class="line">  if (node.nodeType === 3) &#123;</div><div class="line">    if (reg.test(node.nodeValue)) &#123;</div><div class="line">      var name = RegExp.$1;// 正则匹配的第一个括号内的项</div><div class="line">      name = name.trim();</div><div class="line">      // node.nodeValue = vm[name];</div><div class="line">      new Watcher(vm, node, name, &apos;text&apos;);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 劫持节点到DocumentFragment中，在对其所有节点处理后再返回节点</div><div class="line">function nodeToFragment(node, vm) &#123;</div><div class="line">  var flag = document.createDocumentFragment();</div><div class="line">  var child;</div><div class="line">  while(child = node.firstChild) &#123;</div><div class="line">    compile(child, vm);</div><div class="line">    flag.appendChild(child);</div><div class="line">  &#125;</div><div class="line">  return flag; </div><div class="line">&#125;</div><div class="line"></div><div class="line">// Dep主题，有addSub：添加订阅者 和 notify: 提醒订阅者更新的方法</div><div class="line">function Dep () &#123;</div><div class="line">  this.subs = []</div><div class="line">&#125;</div><div class="line"></div><div class="line">Dep.prototype = &#123;</div><div class="line">  addSub: function(sub) &#123;</div><div class="line">    this.subs.push(sub);</div><div class="line">  &#125;, </div><div class="line">  notify: function() &#123;</div><div class="line">    this.subs.forEach(sub =&gt; &#123;</div><div class="line">      sub.update();</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function defineReactive (obj, key, val) &#123;</div><div class="line">  var dep = new Dep();</div><div class="line"></div><div class="line">  // 把主题放到重构变量getter, setter的时候调用</div><div class="line">  Object.defineProperty(obj, key, &#123;</div><div class="line">    get: function() &#123;</div><div class="line">      if (Dep.target) dep.addSub(Dep.target);</div><div class="line">      return val</div><div class="line">    &#125;,</div><div class="line">    set: function (newVal) &#123;</div><div class="line">      if (newVal === val) return </div><div class="line">      val = newVal;</div><div class="line">      // 发布者发布通知</div><div class="line">      dep.notify();</div><div class="line">      console.log(val);</div><div class="line">     &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">function observe (obj, vm) &#123;</div><div class="line">  Object.keys(obj).forEach(key =&gt; &#123;</div><div class="line">    // 由于闭包关系每个key，都有其对应的dep(主题)</div><div class="line">    defineReactive(vm, key, obj[key]);</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">function Vue(options) &#123;</div><div class="line">  this.data = options.data;</div><div class="line"></div><div class="line">  var data = this.data;</div><div class="line"></div><div class="line">  // 为所有data对象的值添加setter方法，同时将vm.data[key]获取值的方式转变成vm[key]</div><div class="line">  observe(data, this);</div><div class="line"></div><div class="line">  var id = options.el;</div><div class="line">  var dom = nodeToFragment(document.getElementById(id), this);</div><div class="line">  // 把编译完成后的dom重新返回到app中</div><div class="line">  document.getElementById(id).appendChild(dom);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var vm = new Vue(&#123;</div><div class="line">  el: &apos;app&apos;,</div><div class="line">  data: &#123;</div><div class="line">    text: &apos;hello world&apos;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/</a><br>2.<a href="http://www.cnblogs.com/kidney/p/6052935.html?utm_source=gold_browser_extension" target="_blank" rel="external">http://www.cnblogs.com/kidney/p/6052935.html?utm_source=gold_browser_extension</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/18/co源码学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/co源码学习笔记/" itemprop="url">co源码学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-18T22:23:34+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="0-关于yield"><a href="#0-关于yield" class="headerlink" title="0. 关于yield"></a>0. 关于yield</h2><ul>
<li>yield 表达式</li>
</ul>
<p>（1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。</p>
<p>（2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。</p>
<p>（3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。</p>
<p>（4）如果该函数没有return语句，则返回的对象的value属性值为undefined。</p>
<p>eg.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function* helloWorldGenerator() &#123;</div><div class="line">  yield &apos;hello&apos;;</div><div class="line">  yield &apos;world&apos;;</div><div class="line">  return &apos;ending&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var hw = helloWorldGenerator();</div><div class="line"></div><div class="line"></div><div class="line">hw.next()</div><div class="line">// &#123; value: &apos;hello&apos;, done: false &#125;</div><div class="line"></div><div class="line">hw.next()</div><div class="line">// &#123; value: &apos;world&apos;, done: false &#125;</div><div class="line"></div><div class="line">hw.next()</div><div class="line">// &#123; value: &apos;ending&apos;, done: true &#125;</div><div class="line"></div><div class="line">hw.next()</div><div class="line">// &#123; value: undefined, done: true &#125;</div></pre></td></tr></table></figure>
<ul>
<li>next</li>
</ul>
<p>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作<strong>上一个</strong>yield表达式的返回值。</p>
<p>eg</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function* f() &#123;</div><div class="line">  for(var i = 0; true; i++) &#123;</div><div class="line">    var reset = yield i;</div><div class="line">    if(reset) &#123; i = -1; &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var g = f();</div><div class="line"></div><div class="line">g.next() // &#123; value: 0, done: false &#125;</div><div class="line">g.next() // &#123; value: 1, done: false &#125;</div><div class="line">g.next(true) // &#123; value: 0, done: false &#125;</div></pre></td></tr></table></figure>
<p>more eg</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function* foo(x) &#123;</div><div class="line">  var y = 2 * (yield (x + 1));</div><div class="line">  var z = yield (y / 3);</div><div class="line">  return (x + y + z);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var a = foo(5);</div><div class="line">a.next() // Object&#123;value:6, done:false&#125;</div><div class="line">a.next() // Object&#123;value:NaN, done:false&#125;</div><div class="line">a.next() // Object&#123;value:NaN, done:true&#125;</div><div class="line"></div><div class="line">var b = foo(5);</div><div class="line">b.next() // &#123; value:6, done:false &#125;</div><div class="line">b.next(12) // &#123; value:8, done:false &#125;</div><div class="line">b.next(13) // &#123; value:42, done:true &#125;</div></pre></td></tr></table></figure>
<p>上面代码中，第二次运行next方法的时候不带参数，导致y的值等于2 * undefined（即NaN），除以3以后还是NaN，因此返回对象的value属性也等于NaN。第三次运行Next方法的时候不带参数，所以z等于undefined，返回对象的value属性等于5 + NaN + undefined，即NaN。</p>
<p>如果向next方法提供参数，返回结果就完全不一样了。上面代码第一次调用b的next方法时，返回x+1的值6；第二次调用next方法，将上一次yield表达式的值设为12，因此y等于24，返回y / 3的值8；第三次调用next方法，将上一次yield表达式的值设为13，因此z等于13，这时x等于5，y等于24，所以return语句的值等于42。</p>
<p>注意，由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。V8 引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。</p>
<h2 id="1-Thunk函数"><a href="#1-Thunk函数" class="headerlink" title="1.Thunk函数"></a>1.Thunk函数</h2><ul>
<li>编译器的”传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function f(m)&#123;</div><div class="line">  return m * 2;     </div><div class="line">&#125;</div><div class="line"></div><div class="line">f(x + 5);</div><div class="line"></div><div class="line">// 等同于</div><div class="line"></div><div class="line">var thunk = function () &#123;</div><div class="line">  return x + 5;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function f(thunk)&#123;</div><div class="line">  return thunk() * 2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中，函数 f 的参数 x + 5 被一个函数替换了。凡是用到原参数的地方，对 Thunk 函数求值即可。<br>这就是 Thunk 函数的定义，它是”传名调用”的一种实现策略，用来替换某个表达式。</p>
<ul>
<li>JS中的thunk函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 正常版本的readFile（多参数版本）</div><div class="line">fs.readFile(fileName, callback);</div><div class="line"></div><div class="line">// Thunk版本的readFile（单参数版本）</div><div class="line">var readFileThunk = Thunk(fileName);</div><div class="line">readFileThunk(callback);</div><div class="line"></div><div class="line">var Thunk = function (fileName)&#123;</div><div class="line">  return function (callback)&#123;</div><div class="line">    return fs.readFile(fileName, callback);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>上面代码中，fs 模块的 readFile 方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做 Thunk 函数</p>
<p>thunk函数转换器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var Thunk = function(fn)&#123;</div><div class="line">  return function ()&#123;</div><div class="line">    var args = Array.prototype.slice.call(arguments);</div><div class="line">    return function (callback)&#123;</div><div class="line">      args.push(callback);</div><div class="line">      return fn.apply(this, args);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>调用之后返回一个函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let aaa = Thunk(xxxx);</div><div class="line">    aaa = function() &#123;</div><div class="line">     var args = Array.prototype.slice.call(arguments);</div><div class="line">     return function (callback)&#123;</div><div class="line">       args.push(callback);</div><div class="line">       return fn.apply(this, args);</div><div class="line">     &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>此时调用 aaa 得，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">let bbb = aaa(x,y,z);</div><div class="line">//等同于</div><div class="line">bbb = function aaa(x,y,z) &#123;</div><div class="line">  var args = [x,y,z];</div><div class="line">  return function (callback)&#123;</div><div class="line">    args.push(callback);</div><div class="line">    return xxx.apply(this, args);</div><div class="line">  &#125;</div><div class="line">&#125; = function (callback) &#123;</div><div class="line">  var args = [x,y,z]</div><div class="line">  args.push(callback);</div><div class="line">  return xxx.apply(this, args)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之后就很清楚了。thunk转换主要起到的作用将多参数函数替换成单参数的版本，且只接受该参数为回调函数.</p>
<ul>
<li>基于thunk函数的自动执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"> var fs = require(&apos;fs&apos;);</div><div class="line">var thunkify = require(&apos;thunkify&apos;);</div><div class="line">var readFile = thunkify(fs.readFile); // 把异步函数thunk化</div><div class="line"></div><div class="line">var gen = function* ()&#123;</div><div class="line">  var r1 = yield readFile(&apos;./index.html&apos;);</div><div class="line">  console.log(r1.toString());</div><div class="line">  var r2 = yield readFile(&apos;./normal.css&apos;);</div><div class="line">  console.log(r2.toString());</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 手动执行的步骤</div><div class="line">var g = gen();</div><div class="line"></div><div class="line">var r1 = g.next()</div><div class="line">r1.value(function(err, data)&#123;</div><div class="line">  if (err) throw err;</div><div class="line">  var r2 = g.next(data);</div><div class="line">  console.log(r1.value.toString())</div><div class="line">  r2.value(function(err, data)&#123;</div><div class="line">    if (err) throw err;</div><div class="line">    g.next(data);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 自动化，写一个递归函数</div><div class="line">function run(fn) &#123;</div><div class="line">  var gen = fn;</div><div class="line"></div><div class="line">  function next(err, data) &#123;</div><div class="line">    var result = gen.next(data);</div><div class="line">    if (result.done) return;</div><div class="line">    console.log(result.value.toString());</div><div class="line">    result.value(next);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  next();</div><div class="line">&#125;</div><div class="line"></div><div class="line">run(gen());</div></pre></td></tr></table></figure>
<h2 id="2-基于Promise对象的自动执行"><a href="#2-基于Promise对象的自动执行" class="headerlink" title="2.基于Promise对象的自动执行"></a>2.基于Promise对象的自动执行</h2><p>Promise对象对上面例子实现手动执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line"></div><div class="line">var readFile = function (fileName)&#123;</div><div class="line">  return new Promise(function (resolve, reject)&#123;</div><div class="line">    fs.readFile(fileName, function(error, data)&#123;</div><div class="line">      if (error) reject(error);</div><div class="line">      resolve(data);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var gen = function* ()&#123;</div><div class="line">  var f1 = yield readFile(&apos;/etc/fstab&apos;);</div><div class="line">  var f2 = yield readFile(&apos;/etc/shells&apos;);</div><div class="line">  console.log(f1.toString());</div><div class="line">  console.log(f2.toString());</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var g = gen();</div><div class="line"></div><div class="line">g.next().value.then(function(data)&#123;</div><div class="line">  g.next(data).value.then(function(data)&#123;</div><div class="line">    g.next(data);</div><div class="line">  &#125;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>由上式的手动执行，可知道Promise 自动执行就是一个递归，程序如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function run(gen)&#123;</div><div class="line">  var g = gen();</div><div class="line"></div><div class="line">  function next(data)&#123;</div><div class="line">    var result = g.next(data);</div><div class="line">    if (result.done) return result.value;</div><div class="line">    result.value.then(function(data)&#123;</div><div class="line">      next(data);</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  next();</div><div class="line">&#125;</div><div class="line"></div><div class="line">run(gen);</div></pre></td></tr></table></figure>
<h2 id="3-co基本思路"><a href="#3-co基本思路" class="headerlink" title="3. co基本思路"></a>3. co基本思路</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function co(gen) &#123;</div><div class="line">  var ctx = this;</div><div class="line"></div><div class="line">  return new Promise(function(resolve, reject) &#123;</div><div class="line">    if (typeof gen === &apos;function&apos;) gen = gen.call(ctx);</div><div class="line">    if (!gen || typeof gen.next !== &apos;function&apos;) return resolve(gen);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>接受generator函数,把它promise化。之后，先判断其是否为generator函数，是则执行函数，获取内部指针，以便通过next()执行，如果不是就返回，并将 Promise 对象的状态改为 resolved 。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function co(gen) &#123;</div><div class="line">  var ctx = this;</div><div class="line"></div><div class="line">  return new Promise(function(resolve, reject) &#123;</div><div class="line">    if (typeof gen === &apos;function&apos;) gen = gen.call(ctx);</div><div class="line">    if (!gen || typeof gen.next !== &apos;function&apos;) return resolve(gen);</div><div class="line"></div><div class="line">    onFulfilled();</div><div class="line">    function onFulfilled(res) &#123;</div><div class="line">      var ret;</div><div class="line">      try &#123;</div><div class="line">        ret = gen.next(res);</div><div class="line">      &#125; catch (e) &#123;</div><div class="line">        return reject(e);</div><div class="line">      &#125;</div><div class="line">      next(ret);</div><div class="line">    &#125;    </div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>把next()执行包装成onFulfilled()函数，作用捕捉错误，将其reject()抛出。最后是next()的实现:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function next(ret) &#123;</div><div class="line">  if (ret.done) return resolve(ret.value);</div><div class="line">  var value = toPromise.call(ctx, ret.value);</div><div class="line">  if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected);</div><div class="line">  return onRejected(new TypeError(&apos;You may only yield a function, promise, generator, array, or object, &apos;</div><div class="line">        + &apos;but the following object was passed: &quot;&apos; + String(ret.value) + &apos;&quot;&apos;));</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ol>
<li>第一句，判断generator函数是否执行完毕，是则resolve，第二句，把执行next()之后得到的结果进行Promise化，第三句，对Promise化后的value，使用 then 方法，为返回值加上回调函数onFulfilled和onRejected，然后通过 onFulfilled 函数再次调用 next 函数。此时上个value会把resolve的结果传到onFulfilled的参数res。</li>
</ol>
<h2 id="4-async-await"><a href="#4-async-await" class="headerlink" title="4. async/await"></a>4. async/await</h2><ul>
<li>了解了以上的知识，就能知道，其实async/await就是一个将 Generator 函数和自动执行器，包装在一起的函数。</li>
</ul>
<p>简单的实现如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">async function fn(args)&#123;</div><div class="line">  // ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 等同于</div><div class="line"></div><div class="line">function fn(args)&#123; </div><div class="line">  return spawn(function*() &#123;</div><div class="line">    // ...</div><div class="line">  &#125;); </div><div class="line">&#125;</div><div class="line"></div><div class="line">function spawn(genF) &#123;</div><div class="line">  return new Promise(function(resolve, reject) &#123;</div><div class="line">    var gen = genF();</div><div class="line">    function step(nextF) &#123;</div><div class="line">      try &#123;</div><div class="line">        var next = nextF();</div><div class="line">      &#125; catch(e) &#123;</div><div class="line">        return reject(e); </div><div class="line">      &#125;</div><div class="line">      if(next.done) &#123;</div><div class="line">        return resolve(next.value);</div><div class="line">      &#125; </div><div class="line">      Promise.resolve(next.value).then(function(v) &#123;</div><div class="line">        step(function() &#123; return gen.next(v); &#125;);      </div><div class="line">      &#125;, function(e) &#123;</div><div class="line">        step(function() &#123; return gen.throw(e); &#125;);</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">    step(function() &#123; return gen.next(undefined); &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://www.ruanyifeng.com/blog/2015/05/co.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2015/05/co.html</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/18/关于缓存的学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/关于缓存的学习笔记/" itemprop="url">关于缓存的学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-18T22:19:02+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><ul>
<li><p>1 Header 字段优先级:<br>Cache-Control &gt; Expires &gt; ETag &gt; Last-Modified</p>
</li>
<li><p>2 一般情况下，使用Cache-Control/Expires会配合Last-Modified/ETag一起使用，因为即使服务器设置缓存时间, 当用户点击“刷新”按钮时，浏览器会忽略缓存继续向服务器发送请求，这时Last-Modified/ETag将能够很好利用304，从而减少响应开销。</p>
</li>
<li><p>3 各字段作用及区别</p>
</li>
</ul>
<p>Expires: 告诉浏览器在过期时间前可以使用缓存副本;<br>Cache-Control: 参数（no-cache, no-store, max-age, public, private）;<br>Last-Modified:告诉浏览器资源最后修改时间;<br>ETag: 告诉浏览器当前资源在服务器的唯一标识符（规则服务器决定）</p>
<p>区别：<br>Expires 与 Cache-Controle:</p>
<p>Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致;</p>
<p>ETag 与 Last-Modified:</p>
<p>你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</p>
<p>a 、Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的新鲜度<br>b 、如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存<br>c 、有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</p>
<p>Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</p>
<p>Expires/Cache-Controle 与 ETag/Last-Modified:</p>
<p>配置Last-Modified/ETag的情况下，浏览器再次访问统一URI的资源，还是会发送请求到服务器询问文件是否已经修改，如果没有，服务器会只发送一个304回给浏览器，告诉浏览器直接从自己本地的缓存取数据；如果修改过那就整个数据重新发给浏览器；</p>
<p>Cache-Control/Expires则不同，如果检测到本地的缓存还是有效的时间范围内，浏览器直接使用本地副本，不会发送任何请求。即当本地副本根据Cache-Control/Expires发现还在有效期内时，则不会再次发送请求去服务器询问修改时间（Last-Modified）或实体标识（Etag）了。</p>
<ul>
<li>4 用户操作对浏览器缓存影响:</li>
</ul>
<p>当用户在按F5进行刷新的时候，会忽略Expires/Cache-Control的设置，会再次发送请求去服务器请求，而Last-Modified/Etag还是有效的，服务器会根据情况判断返回304还是200；而当用户使用Ctrl+F5进行强制刷新的时候，只是所有的缓存机制都将失效，重新从服务器拉去资源。</p>
<ul>
<li>5 无法被浏览器缓存的请求:</li>
</ul>
<p>a. HTTP信息头中包含Cache-Control:no-cache，pragma:no-cache，或Cache-Control:max-age=0等告诉浏览器不用缓存的请求<br>b. 需要根据Cookie，认证信息等决定输入内容的动态请求是不能被缓存的<br>c. 经过HTTPS安全加密的请求<br>d. POST请求无法被缓存<br>e. HTTP响应头中不包含Last-Modified/Etag，也不包含Cache-Control/Expires的请求无法被缓存</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://www.alloyteam.com/2012/03/web-cache-1-web-cache-overview/" target="_blank" rel="external">http://www.alloyteam.com/2012/03/web-cache-1-web-cache-overview/</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="John Doe" />
          <p class="site-author-name" itemprop="name">John Doe</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
